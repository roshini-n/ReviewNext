import { Component, OnInit, inject, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTableModule, MatTableDataSource } from '@angular/material/table';
import { MatPaginatorModule, MatPaginator } from '@angular/material/paginator';
import { MatSortModule, MatSort } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatChipsModule } from '@angular/material/chips';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialogModule, MatDialog } from '@angular/material/dialog';
import { FormsModule } from '@angular/forms';
import { ReviewService } from '../../../services/review.service';
import { BookReviewService } from '../../../services/bookreview.service';
import { MovieReviewService } from '../../../services/movieReview.service';
import { Review } from '../../../models/review.model';

interface AdminReview extends Review {
  category?: string;
  contentTitle?: string;
}

@Component({
  selector: 'app-admin-reviews',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatChipsModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatDialogModule,
    FormsModule
  ],
  templateUrl: './admin-reviews.component.html',
  styleUrls: ['./admin-reviews.component.css']
})
export class AdminReviewsComponent implements OnInit {
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private reviewService = inject(ReviewService);
  private bookReviewService = inject(BookReviewService);
  private movieReviewService = inject(MovieReviewService);
  private snackBar = inject(MatSnackBar);
  private dialog = inject(MatDialog);
  
  displayedColumns: string[] = ['username', 'category', 'rating', 'reviewText', 'datePosted', 'actions'];
  dataSource = new MatTableDataSource<AdminReview>([]);
  isLoading = true;
  searchQuery = '';
  selectedCategory = 'all';
  selectedRating = 'all';
  
  categories = [
    { value: 'all', label: 'All Categories' },
    { value: 'games', label: 'Games' },
    { value: 'books', label: 'Books' },
    { value: 'movies', label: 'Movies' },
    { value: 'webSeries', label: 'Web Series' },
    { value: 'electronicGadgets', label: 'Electronic Gadgets' },
    { value: 'beautyProducts', label: 'Beauty Products' }
  ];
  
  ratings = [
    { value: 'all', label: 'All Ratings' },
    { value: '5', label: '5 Stars' },
    { value: '4', label: '4 Stars' },
    { value: '3', label: '3 Stars' },
    { value: '2', label: '2 Stars' },
    { value: '1', label: '1 Star' }
  ];
  
  ngOnInit(): void {
    this.loadReviews();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    
    // Custom filter function
    this.dataSource.filterPredicate = (data: AdminReview, filter: string) => {
      const filterObject = JSON.parse(filter);
      
      // Text search
      const searchString = filterObject.search.toLowerCase();
      const textMatch = !searchString || 
        (data.username || '').toLowerCase().includes(searchString) ||
        (data.reviewText || '').toLowerCase().includes(searchString) ||
        (data.contentTitle || '').toLowerCase().includes(searchString);
      
      // Category filter
      const categoryMatch = filterObject.category === 'all' || data.category === filterObject.category;
      
      // Rating filter
      const ratingMatch = filterObject.rating === 'all' || data.rating.toString() === filterObject.rating;
      
      return textMatch && categoryMatch && ratingMatch;
    };
  }

  loadReviews(): void {
    this.isLoading = true;
    const allReviews: AdminReview[] = [];
    
    // Load game reviews
    this.reviewService.getAllReviews().subscribe({
      next: (gameReviews: Review[]) => {
        const reviews: AdminReview[] = gameReviews.map((review: Review) => ({
          ...review,
          category: 'games',
          contentTitle: 'Game Review'
        }));
        allReviews.push(...reviews);
        this.dataSource.data = [...allReviews];
        this.applyFilter();
        this.isLoading = false;
      },
      error: (error: any) => {
        console.error('Error loading game reviews:', error);
        this.isLoading = false;
      }
    });
  }

  applyFilter(): void {
    const filterValue = {
      search: this.searchQuery.trim(),
      category: this.selectedCategory,
      rating: this.selectedRating
    };
    
    this.dataSource.filter = JSON.stringify(filterValue);
    
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  clearFilters(): void {
    this.searchQuery = '';
    this.selectedCategory = 'all';
    this.selectedRating = 'all';
    this.applyFilter();
  }

  editReview(review: AdminReview): void {
    // In a real implementation, open an edit dialog
    console.log('Edit review:', review);
    this.showMessage(`Edit functionality for review - Feature coming soon`);
  }

  deleteReview(review: AdminReview): void {
    const confirmMessage = `Are you sure you want to delete this review by ${review.username}?`;
    if (confirm(confirmMessage)) {
      // Use the appropriate service based on category
      this.reviewService.deleteReview(review.id).subscribe({
        next: () => {
          this.showMessage('Review deleted successfully');
          this.loadReviews();
        },
        error: (error: any) => {
          console.error('Error deleting review:', error);
          this.showMessage('Error deleting review');
        }
      });
    }
  }

  flagReview(review: AdminReview): void {
    // In a real implementation, you would update the review's flagged status
    console.log('Flag review:', review);
    this.showMessage(`Review by ${review.username} has been flagged for moderation`);
  }

  exportReviews(): void {
    const csvData = this.convertToCSV(this.dataSource.data);
    this.downloadCSV(csvData, 'reviews-export.csv');
    this.showMessage('Reviews exported successfully');
  }

  getStarArray(rating: number): number[] {
    return Array(5).fill(0).map((_, i) => i + 1);
  }

  private convertToCSV(reviews: AdminReview[]): string {
    const headers = ['Username', 'Category', 'Content Title', 'Rating', 'Review Text', 'Date Posted'];
    const csvContent = [
      headers.join(','),
      ...reviews.map(review => [
        `"${review.username || 'Anonymous'}"`,
        `"${review.category || 'Unknown'}"`,
        `"${review.contentTitle || 'Unknown'}"`,
        review.rating.toString(),
        `"${(review.reviewText || '').replace(/"/g, '""')}"`,
        `"${review.datePosted?.toString() || 'Unknown'}"`
      ].join(','))
    ];
    return csvContent.join('\n');
  }

  private downloadCSV(csvContent: string, fileName: string): void {
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }

  private showMessage(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom'
    });
  }
}
export class AdminReviewsComponent implements OnInit {
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private reviewService = inject(ReviewService);
  private bookReviewService = inject(BookReviewService);
  private movieReviewService = inject(MovieReviewService);
  private dialog = inject(MatDialog);
  private snackBar = inject(MatSnackBar);
  
  displayedColumns: string[] = ['content', 'user', 'rating', 'review', 'date', 'actions'];
  dataSource = new MatTableDataSource<AdminReview>([]);
  isLoading = true;
  searchQuery = '';
  selectedCategory = 'all';
  selectedRating = 'all';
  
  categories = [
    { value: 'all', label: 'All Categories' },
    { value: 'games', label: 'Games' },
    { value: 'books', label: 'Books' },
    { value: 'movies', label: 'Movies' },
    { value: 'webSeries', label: 'Web Series' },
    { value: 'electronicGadgets', label: 'Electronic Gadgets' },
    { value: 'beautyProducts', label: 'Beauty Products' }
  ];

  ratings = [
    { value: 'all', label: 'All Ratings' },
    { value: '5', label: '5 Stars' },
    { value: '4', label: '4 Stars' },
    { value: '3', label: '3 Stars' },
    { value: '2', label: '2 Stars' },
    { value: '1', label: '1 Star' }
  ];
  
  ngOnInit(): void {
    this.loadReviews();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    
    // Custom filter function
    this.dataSource.filterPredicate = (data: AdminReview, filter: string) => {
      const filterObject = JSON.parse(filter);
      
      // Text search
      const searchString = filterObject.search.toLowerCase();
      const textMatch = !searchString || 
        data.username.toLowerCase().includes(searchString) ||
        (data.reviewText || '').toLowerCase().includes(searchString) ||
        (data.contentTitle || '').toLowerCase().includes(searchString);
      
      // Category filter
      const categoryMatch = filterObject.category === 'all' || data.category === filterObject.category;
      
      // Rating filter
      const ratingMatch = filterObject.rating === 'all' || data.rating.toString() === filterObject.rating;
      
      return textMatch && categoryMatch && ratingMatch;
    };
  }

  loadReviews(): void {
    this.isLoading = true;
    const allReviews: AdminReview[] = [];
    
    // Load game reviews
    this.reviewService.getAllReviews().subscribe({
      next: (gameReviews: any[]) => {
        const reviews: AdminReview[] = gameReviews.map((review: any) => ({
          id: review.id,
          username: review.username || 'Anonymous',
          rating: review.rating || 0,
          reviewText: review.reviewText || '',
          datePosted: review.datePosted,
          category: 'games',
          contentTitle: 'Game Review',
          userId: review.userId
        }));
        allReviews.push(...reviews);
        this.dataSource.data = [...allReviews];
      },
      error: (error) => {
        console.error('Error loading game reviews:', error);
        this.isLoading = false;
      }
    });

    // Load book reviews (if the service has the method)
    try {
      if (this.bookReviewService && typeof (this.bookReviewService as any).getAllReviews === 'function') {
        (this.bookReviewService as any).getAllReviews().subscribe({
          next: (bookReviews: any[]) => {
            const bookReviewsFormatted: AdminReview[] = bookReviews.map((review: any) => ({
              id: review.id,
              username: review.username || 'Anonymous',
              rating: review.rating || 0,
              reviewText: review.reviewText || '',
              datePosted: review.datePosted,
              category: 'books',
              contentTitle: 'Book Review',
              userId: review.userId
            }));
            allReviews.push(...bookReviewsFormatted);
            this.dataSource.data = [...allReviews];
          },
          error: (error) => console.error('Error loading book reviews:', error)
        });
      }
    } catch (error) {
      console.error('Book review service not available:', error);
    }

    this.isLoading = false;
  }
            this.applyFilter();
          },
          error: () => {
            this.dataSource.data = reviews;
            this.isLoading = false;
            this.applyFilter();
          }
        });
      },
      error: (error) => {
        console.error('Error loading reviews:', error);
        this.showMessage('Error loading reviews');
        this.isLoading = false;
      }
    });
  }

  applyFilter(): void {
    const filterValue = {
      search: this.searchQuery.trim(),
      category: this.selectedCategory,
      rating: this.selectedRating
    };
    
    this.dataSource.filter = JSON.stringify(filterValue);
    
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  clearFilters(): void {
    this.searchQuery = '';
    this.selectedCategory = 'all';
    this.selectedRating = 'all';
    this.applyFilter();
  }

  editReview(review: AdminReview): void {
    // In a real implementation, open an edit dialog
    console.log('Edit review:', review);
    this.showMessage(`Edit functionality for review - Feature coming soon`);
  }

  deleteReview(review: AdminReview): void {
    const confirmMessage = `Are you sure you want to delete this review by ${review.username}?`;
    if (confirm(confirmMessage)) {
      // Use the appropriate service based on category
      let deleteService: any;
      switch (review.category) {
        case 'books':
          deleteService = this.bookReviewService;
          break;
        case 'movies':
          deleteService = this.movieReviewService;
          break;
        default:
          deleteService = this.reviewService;
      }

      if (deleteService.deleteReview) {
        deleteService.deleteReview(review.id).subscribe({
          next: () => {
            this.showMessage('Review deleted successfully');
            this.loadReviews();
          },
          error: (error: any) => {
            console.error('Error deleting review:', error);
            this.showMessage('Error deleting review');
          }
        });
      }
    }
  }

  flagReview(review: AdminReview): void {
    // In a real implementation, you would flag the review for further investigation
    console.log('Flag review:', review);
    this.showMessage(`Review by ${review.username} has been flagged for moderation`);
  }

  exportReviews(): void {
    const csvData = this.convertToCSV(this.dataSource.data);
    this.downloadCSV(csvData, 'reviews-export.csv');
    this.showMessage('Reviews exported successfully');
  }

  getStarArray(rating: number): number[] {
    return Array(5).fill(0).map((_, i) => i + 1);
  }

  private convertToCSV(reviews: AdminReview[]): string {
    const headers = ['Username', 'Category', 'Content Title', 'Rating', 'Review Text', 'Date Posted'];
    const csvContent = [
      headers.join(','),
      ...reviews.map(review => [
        `"${review.username}"`,
        `"${review.category || 'Unknown'}"`,
        `"${review.contentTitle || 'Unknown'}"`,
        review.rating.toString(),
        `"${(review.reviewText || '').replace(/"/g, '""')}"`,
        `"${review.datePosted?.toString() || 'Unknown'}"`
      ].join(','))
    ];
    return csvContent.join('\n');
  }

  private downloadCSV(csvContent: string, fileName: string): void {
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }

  private showMessage(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      horizontalPosition: 'center',
      verticalPosition: 'bottom'
    });
  }
}
